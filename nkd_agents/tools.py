import asyncio
import difflib
import logging
import os
import subprocess
from pathlib import Path
from typing import Iterator

from .llm import LLM, loop

logger = logging.getLogger(__name__)

# -----------------------------------------------------------------------------
# Helper functions for diffs
# -----------------------------------------------------------------------------


def generate_diff(
    original_content: str, new_content: str, file_path: str
) -> Iterator[str]:
    """
    Generate a unified diff between original and new content.

    Args:
        original_content: The original content of the file
        new_content: The new content after changes
        file_path: The path to the file being modified

    Returns:
        A list of diff lines with unified diff format
    """
    old_lines = original_content.splitlines()
    new_lines = new_content.splitlines()

    return difflib.unified_diff(
        old_lines,
        new_lines,
        fromfile=f"a/{file_path}",
        tofile=f"b/{file_path}",
        lineterm="",
        n=3,
    )


def display_diff(diff: Iterator[str], file_path: str) -> None:
    """
    Display a colorized diff in the console.

    Args:
        diff_lines: The diff lines generated by generate_diff
        file_path: The path to the file being modified
    """
    logger.info(f"\n[bold]Update({file_path})[/bold]")
    logger.info(f"[dim]└─ Updated {file_path} with additions and removals[/dim]")

    for line in diff:
        if line.startswith("-"):
            logger.info(f"[red]{line}[/red]")  # Red for removals
        elif line.startswith("+"):
            logger.info(f"[green]{line}[/green]")  # Green for additions
        else:
            logger.info(f"[dim]{line}[/dim]")  # Gray for context


# -----------------------------------------------------------------------------
# Coding Assistant Tools
# -----------------------------------------------------------------------------


async def read_file(path: str) -> str:
    """Read the contents of a given relative file path. Use this when you want to see what's inside a file. Do not use this with directory names."""
    file_path = Path(path)
    try:
        content = file_path.read_text(encoding="utf-8")
        logger.info(f"[bold]Read({path})[/bold]")
        return content
    except FileNotFoundError:
        return f"Error: File '{path}' not found"
    except PermissionError:
        return f"Error: Permission denied accessing '{path}'"
    except Exception as e:
        return f"Error reading file '{path}': {str(e)}"


async def edit_file(path: str, old_str: str, new_str: str) -> str:
    """Make edits to a text file. Replaces 'old_str' with 'new_str' in the given file.
    'old_str' and 'new_str' MUST be different from each other.
    If the file specified with path doesn't exist, it will be created.
    When making multiple edits to a file, use this function separately for each edit rather than attempting to make all changes at once."""
    file_path = Path(path)

    if old_str == new_str:
        return "Error: old_str and new_str must be different"

    try:
        if file_path.exists():
            content = file_path.read_text(encoding="utf-8")

            if old_str != "" and old_str not in content:
                return f"Error: old_str not found in file '{path}'"

            new_content = content.replace(old_str, new_str)
        else:
            if old_str != "":
                return f"Error: File '{path}' not found"

            file_path.parent.mkdir(parents=True, exist_ok=True)
            content = ""
            new_content = new_str

        if os.getenv("EDIT_APPROVAL", "enabled").lower() == "enabled":
            diff_lines = generate_diff(content, new_content, path)

            if diff_lines:
                display_diff(diff_lines, path)

                approval = input("Apply changes? (y/n): ").strip().lower()
                if approval != "y":
                    return "User cancelled edit. Ask user for new instructions."
            else:
                logger.info("No changes detected")
                return "No changes to apply"

        file_path.write_text(new_content, encoding="utf-8")
        return f"Updated({path})"
    except Exception as e:
        return f"Error editing file '{path}': {str(e)}"


BASH_CMDS_APPROVAL_REQUIRED = ["rm", "rmdir", "rm -rf", "git reset"]


async def execute_bash(command: str) -> str:
    """Execute a bash command and return a formatted string with the results."""
    if any([command.strip().startswith(x) for x in BASH_CMDS_APPROVAL_REQUIRED]):
        approval = input(f"Cmd {command.strip()} requires approval. y to proceed): ")
        if approval.strip().lower() != "y":
            return "Command execution cancelled by user."

    try:
        result = subprocess.run(
            ["bash", "-c", command], capture_output=True, text=True, timeout=10
        )

        result_str = f"STDOUT:\n{result.stdout}"
        if result.stderr.strip():
            result_str += f"\n\n[red]STDERR:\n{result.stderr}"
        if result.returncode != 0:
            result_str += f"\n\n[red]EXIT CODE: {result.returncode}[/red]"

        logger.info(f"[cyan bold]Bash({command})[/cyan bold] {result_str}")
        return result_str
    except Exception as e:
        return f"Error executing command: {str(e)}"


# -----------------------------------------------------------------------------
# Sub-Agent Management Tools
# -----------------------------------------------------------------------------


async def task(
    prompt: str,
    description: str = "",
    model: str = "claude-sonnet-4-5",
) -> str:
    """Task a sub-agent to work on a specific task autonomously.

    The sub-agent will work on the given task with access to file read/edit and bash execution tools.
    Use this for complex, multi-step tasks that benefit from focused attention.

    Args:
        prompt: Detailed description of what the sub-agent should accomplish. Be specific about:
            - What the task is and why it's needed
            - What files or resources might be relevant
            - What the expected output or outcome should be
            - Any constraints or requirements
        description: Short 3-5 word summary of the task for progress tracking (e.g., "Refactor auth module")
        model: Claude model to use. Options:
            - "claude-sonnet-4-5" (default) - Balanced performance
            - "claude-haiku-4-5" - Faster, more cost-effective for simpler tasks
            - "claude-opus-4-1" - Most capable for complex reasoning

    Returns:
        Summary of what the sub-agent accomplished

    Examples:
        # Simple task with auto-generated description
        await task("Find all TODO comments in Python files and create a summary")

        # Complex task with explicit description
        await task(
            prompt="Refactor the authentication module to use OAuth2 instead of session tokens",
            description="OAuth2 refactor",
            model="claude-opus-4-20250514"
        )
    """

    task_label = (
        description
        if description
        else prompt[:50] + ("..." if len(prompt) > 50 else "")
    )

    logger.info(f"\n[yellow bold]→ Spawning sub-agent:[/yellow bold] {task_label}")
    logger.info(f"[dim]  Model: {model}[/dim]")

    tools = [read_file, edit_file, execute_bash]
    sub_agent, q = LLM(tools=tools, model=model), asyncio.Queue()
    await q.put([{"type": "text", "text": prompt}])

    try:
        final_output = await loop(sub_agent, q)
        result = f"""✅ Sub-agent completed: {task_label}

Final response:
{final_output}

Note: Any files modified by the sub-agent are now available in your workspace."""

        logger.info(f"[green bold]✓ Sub-agent completed:[/green bold] {task_label}\n")
        return result

    except Exception as e:
        error_msg = f"❌ Sub-agent encountered an error: {str(e)}"
        logger.info(f"[red bold]✗ Sub-agent failed:[/red bold] {task_label}")
        logger.exception("Sub-agent execution failed", exc_info=e)
        return error_msg
