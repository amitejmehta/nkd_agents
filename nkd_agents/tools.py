import difflib
import logging
import os
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Iterator

from .cli_config import console
from .llm import LLM, loop
from .util import render

logger = logging.getLogger(__name__)

# -----------------------------------------------------------------------------
# Helper functions for diffs
# -----------------------------------------------------------------------------


def generate_diff(
    original_content: str, new_content: str, file_path: str
) -> Iterator[str]:
    """
    Generate a unified diff between original and new content.

    Args:
        original_content: The original content of the file
        new_content: The new content after changes
        file_path: The path to the file being modified

    Returns:
        A list of diff lines with unified diff format
    """
    old_lines = original_content.splitlines()
    new_lines = new_content.splitlines()

    return difflib.unified_diff(
        old_lines,
        new_lines,
        fromfile=f"a/{file_path}",
        tofile=f"b/{file_path}",
        lineterm="",
        n=3,
    )


def display_diff(diff: Iterator[str], file_path: str) -> None:
    """
    Display a colorized diff in the console.

    Args:
        diff_lines: The diff lines generated by generate_diff
        file_path: The path to the file being modified
    """
    console.print(f"\n[bold]Update({file_path})[/bold]")
    console.print(f"[dim]└─ Updated {file_path} with additions and removals[/dim]")

    for line in diff:
        if line.startswith("-"):
            console.print(f"[red]{line}[/red]")  # Red for removals
        elif line.startswith("+"):
            console.print(f"[green]{line}[/green]")  # Green for additions
        else:
            console.print(f"[dim]{line}[/dim]")  # Gray for context


# -----------------------------------------------------------------------------
# Coding Assistant Tools
# -----------------------------------------------------------------------------


async def read_file(path: str) -> str:
    """Read the contents of a given relative file path. Use this when you want to see what's inside a file. Do not use this with directory names."""
    file_path = Path(path)
    try:
        content = file_path.read_text(encoding="utf-8")
        console.print(f"[bold]Read({path})[/bold]")
        return content
    except FileNotFoundError:
        return f"Error: File '{path}' not found"
    except PermissionError:
        return f"Error: Permission denied accessing '{path}'"
    except Exception as e:
        return f"Error reading file '{path}': {str(e)}"


async def edit_file(path: str, old_str: str, new_str: str) -> str:
    """Make edits to a text file. Replaces 'old_str' with 'new_str' in the given file.
    'old_str' and 'new_str' MUST be different from each other.
    If the file specified with path doesn't exist, it will be created.
    When making multiple edits to a file, use this function separately for each edit rather than attempting to make all changes at once."""
    file_path = Path(path)

    if old_str == new_str:
        return "Error: old_str and new_str must be different"

    try:
        if file_path.exists():
            content = file_path.read_text(encoding="utf-8")

            if old_str != "" and old_str not in content:
                return f"Error: old_str not found in file '{path}'"

            new_content = content.replace(old_str, new_str)
        else:
            if old_str != "":
                return f"Error: File '{path}' not found"

            file_path.parent.mkdir(parents=True, exist_ok=True)
            content = ""
            new_content = new_str

        if os.getenv("EDIT_APPROVAL", "enabled").lower() == "enabled":
            diff_lines = generate_diff(content, new_content, path)

            if diff_lines:
                display_diff(diff_lines, path)

                approval = input("Apply changes? (y/n): ").strip().lower()
                if approval != "y":
                    return "User cancelled edit. Ask user for new instructions."
            else:
                console.print("No changes detected")
                return "No changes to apply"

        file_path.write_text(new_content, encoding="utf-8")
        return f"Updated({path})"
    except Exception as e:
        return f"Error editing file '{path}': {str(e)}"


BASH_CMDS_APPROVAL_REQUIRED = ["rm", "rmdir", "rm -rf", "git reset"]


async def execute_bash(command: str) -> str:
    """Execute a bash command and return a formatted string with the results."""
    if any([command.strip().startswith(x) for x in BASH_CMDS_APPROVAL_REQUIRED]):
        approval = input(f"Cmd {command.strip()} requires approval. y to proceed): ")
        if approval.strip().lower() != "y":
            return "Command execution cancelled by user."

    try:
        result = subprocess.run(
            ["bash", "-c", command], capture_output=True, text=True, timeout=10
        )
        result_str = f"STDOUT:\n{result.stdout}\nSTDERR:\n{result.stderr}\nEXIT CODE: {result.returncode}"
        console.print(f"[cyan bold]Bash({command}):[/cyan bold] {result_str}")
        return result_str
    except Exception as e:
        return f"Error executing command: {str(e)}"


# -----------------------------------------------------------------------------
# Sub-Agent Management Tools
# -----------------------------------------------------------------------------


async def spawn_subagent(task: str, report_file: str = "research_report.md") -> str:
    """Spawn a sub-agent to work on a specific task and contribute to a shared research report.

    The sub-agent will work on the given task and update the shared report file.
    Results are automatically merged back into the parent agent's context through the report file.

    Args:
        task: Clear description of what the sub-agent should accomplish
        report_file: Path to the shared markdown research report (default: research_report.md)
        agent_type: Type of agent to spawn (default: 'code', options: 'code', 'research')

    Returns:
        Summary of what the sub-agent accomplished
    """

    console.print(f"[yellow bold]Spawning sub-agent for task:[/yellow bold] {task}")

    report_path = Path(report_file)
    if not report_path.exists():
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        report_path.write_text(f"# Research Report\n\n*Started: {timestamp}*\n\n")

    vars = {"task": task, "report_file": report_file}
    sub_agent_prompt = render(Path("nkd_agents/prompts/subagent.j2"), vars)

    tools = [read_file, edit_file, execute_bash]
    sub_agent = LLM(system_prompt=sub_agent_prompt, tools=tools)

    task_prompt = f"""I need to work on this specific task: {task}

    First, let me read the current research report to understand what's already been done, 
    then I'll work on my assigned task and update the report with my findings."""

    try:
        final_output = await loop(sub_agent, [{"type": "text", "text": task_prompt}])

        if report_path.exists():
            current_report = report_path.read_text()
            # Find sections that might be from this sub-agent (simple heuristic)
            report_lines = current_report.split("\n")
            summary_lines = [
                line for line in report_lines[-30:] if line.strip()
            ]  # Last 30 non-empty lines
            recent_section = "\n".join(summary_lines)
        else:
            recent_section = "No report file found after sub-agent execution"

        result = f"""✅ Sub-agent completed task: {task}

        📊 Report updated at: {report_file}

        🔍 Recent additions to report:
        {recent_section}

        💬 Sub-agent final response: {final_output}

        The research report has been updated and is available for your review. You can read the full report using the read_file tool."""

        console.print(f"[green bold]Sub-agent task completed:[/green bold] {task}")
        return result

    except Exception as e:
        error_msg = f"❌ Sub-agent encountered an error: {str(e)}"
        console.print(f"[red bold]Sub-agent error:[/red bold] {error_msg}")
        return error_msg
