import asyncio
import difflib
import logging
import subprocess
from contextvars import ContextVar
from pathlib import Path
from typing import Iterator

from .llm import LLM
from .loop import loop

logger = logging.getLogger(__name__)


# -----------------------------------------------------------------------------
# Helper functions for diffs
# -----------------------------------------------------------------------------


def generate_diff(
    original_content: str, new_content: str, file_path: str
) -> Iterator[str]:
    """
    Generate a unified diff between original and new content.

    Args:
        original_content: The original content of the file
        new_content: The new content after changes
        file_path: The path to the file being modified

    Returns:
        A list of diff lines with unified diff format
    """
    old_lines = original_content.splitlines()
    new_lines = new_content.splitlines()

    return difflib.unified_diff(
        old_lines,
        new_lines,
        fromfile=f"a/{file_path}",
        tofile=f"b/{file_path}",
        lineterm="",
        n=3,
    )


def display_diff(diff: Iterator[str], file_path: str) -> None:
    """
    Display a colorized diff in the console.

    Args:
        diff_lines: The diff lines generated by generate_diff
        file_path: The path to the file being modified
    """
    logger.info(f"\n[bold]Update({file_path})[/bold]")
    logger.info(f"[dim]└─ Updated {file_path} with additions and removals[/dim]")

    for line in diff:
        if line.startswith("-"):
            logger.info(f"[red]{line}[/red]")  # Red for removals
        elif line.startswith("+"):
            logger.info(f"[green]{line}[/green]")  # Green for additions
        else:
            logger.info(f"[dim]{line}[/dim]")  # Gray for context


# -----------------------------------------------------------------------------
# Coding Assistant Tools
# -----------------------------------------------------------------------------


content_var = ContextVar[str | None]("content", default=None)


async def edit_string(old_str: str, new_str: str, content: str | None = None) -> str:
    """Make edits to a string. Replaces 'old_str' with 'new_str' in the given string."""
    content = content or content_var.get()
    if content is None:
        return "Error: No content to edit"
    if old_str not in content:
        return "Error: old_str not found in content"
    if old_str == new_str:
        return "Error: old_str and new_str must be different"
    return content.replace(old_str, new_str)


async def read_file(path: str) -> str:
    """Read the contents of a given relative file path. Use this when you want to see what's inside a file. Do not use this with directory names."""
    try:
        content = Path(path).read_text(encoding="utf-8")
        logger.info(f"[bold]Read({path})[/bold]")
        return content
    except FileNotFoundError:
        return f"Error: File '{path}' not found"
    except PermissionError:
        return f"Error: Permission denied accessing '{path}'"
    except Exception as e:
        return f"Error reading file '{path}': {str(e)}"


async def edit_file(path: str, old_str: str, new_str: str) -> str:
    """Make edits to a text file. Replaces 'old_str' with 'new_str' in the given file.
    Returns the following error messages:
    - Error: File '{path}' is empty
    - Error: 'old_str' not found in file content
    - Error: 'old_str' and 'new_str' must be different
    - Error: File '{path}' not found
    - Error: Permission denied accessing '{path}'
    - Error: Error editing file '{path}': {str(e)}

    Best Practice for Multiple Edits:
    When editing multiple parts of a file, best practice is to use this function
    once for each edit rather than one large edit.
    """
    try:
        content = Path(path).read_text(encoding="utf-8")
        if content == "":
            return f"Error: File '{path}' is empty"
        if old_str not in content:
            return "Error: old_str not found in file content"
        if old_str == new_str:
            return "Error: old_str and new_str must be different"

        edited_content = content.replace(old_str, new_str)
        Path(path).write_text(edited_content, encoding="utf-8")
        return f"Updated {path}"
    except FileNotFoundError:
        return f"Error: File '{path}' not found"
    except PermissionError:
        return f"Error: Permission denied accessing '{path}'"
    except Exception as e:
        return f"Error editing file '{path}': {str(e)}"


async def execute_bash(command: str) -> str:
    """Execute a bash command and return a formatted string with the results."""
    try:
        input = ["bash", "-c", command]
        result = subprocess.run(
            input, capture_output=True, text=True, timeout=10, cwd=Path.cwd()
        )
        return f"STDOUT:\n{result.stdout}\nSTDERR:\n{result.stderr}\nEXIT CODE: {result.returncode}"
    except Exception as e:
        return f"Error executing command: {str(e)}"


# -----------------------------------------------------------------------------
# Sub-Agent Management Tools
# -----------------------------------------------------------------------------


async def task(prompt: str, description: str, model: str = "claude-sonnet-4-5") -> str:
    """Task a sub-agent to work on a specific task autonomously.

    The sub-agent will work on the given task with access to file read/edit and bash execution tools.
    Use this for complex, multi-step tasks that benefit from focused attention.

    Args:
        prompt: Detailed description of what the sub-agent should accomplish. Be specific about:
            - What the task is and why it's needed
            - What files or resources might be relevant
            - What the expected output or outcome should be
            - Any constraints or requirements
        description: Short 3-5 word summary of the task for progress tracking (e.g., "Refactor auth module")
        model: Claude model to use. Options:
            - "claude-sonnet-4-5" (default) - Balanced performance
            - "claude-haiku-4-5" - Faster, more cost-effective for simpler tasks
            - "claude-opus-4-1" - Most capable for complex reasoning

    Returns:
        Summary of what the sub-agent accomplished
    """

    task_label = (
        description
        if description
        else prompt[:50] + ("..." if len(prompt) > 50 else "")
    )

    logger.info(f"\n[yellow bold]→ Spawning sub-agent:[/yellow bold] {task_label}")
    logger.info(f"[dim]  Model: {model}[/dim]")

    tools = [read_file, edit_file, execute_bash]
    sub_agent, q = LLM(tools=tools, model=model), asyncio.Queue()
    await q.put([{"type": "text", "text": prompt}])

    try:
        final_output = await loop(sub_agent, q)
        result = f"""✅ Sub-agent completed: {task_label}

Final response:
{final_output}

Note: Any files modified by the sub-agent are now available in your workspace."""

        logger.info(f"[green bold]✓ Sub-agent completed:[/green bold] {task_label}\n")
        return result

    except Exception as e:
        error_msg = f"❌ Sub-agent encountered an error: {str(e)}"
        logger.info(f"[red bold]✗ Sub-agent failed:[/red bold] {task_label}")
        logger.exception("Sub-agent execution failed", exc_info=e)
        return error_msg
