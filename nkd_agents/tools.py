import difflib
import os
import subprocess
from pathlib import Path
from typing import Iterator

from .config import logger

# -----------------------------------------------------------------------------
# Helper functions for diffs
# -----------------------------------------------------------------------------


def generate_diff(
    original_content: str, new_content: str, file_path: str
) -> Iterator[str]:
    """
    Generate a unified diff between original and new content.

    Args:
        original_content: The original content of the file
        new_content: The new content after changes
        file_path: The path to the file being modified

    Returns:
        A list of diff lines with unified diff format
    """
    old_lines = original_content.splitlines()
    new_lines = new_content.splitlines()

    return difflib.unified_diff(
        old_lines,
        new_lines,
        fromfile=f"a/{file_path}",
        tofile=f"b/{file_path}",
        lineterm="",
        n=3,
    )


def display_diff(diff: Iterator[str], file_path: str) -> None:
    """
    Display a colorized diff in the console.

    Args:
        diff_lines: The diff lines generated by generate_diff
        file_path: The path to the file being modified
    """
    print(f"\n\033[1mUpdate({file_path})\033[0m")
    print(f"\033[90m└─ Updated {file_path} with additions and removals\033[0m")

    for line in diff:
        if line.startswith("-"):
            print(f"\033[31m{line}\033[0m")  # Red for removals
        elif line.startswith("+"):
            print(f"\033[32m{line}\033[0m")  # Green for additions
        else:
            print(f"\033[90m{line}\033[0m")  # Gray for context


# -----------------------------------------------------------------------------
# Coding Assistant Tools
# -----------------------------------------------------------------------------


async def read_file(path: str) -> str:
    """Read the contents of a given relative file path. Use this when you want to see what's inside a file. Do not use this with directory names."""
    file_path = Path(path)
    try:
        content = file_path.read_text(encoding="utf-8")
        logger.info(f"Read({path})")
        return content
    except FileNotFoundError:
        return f"Error: File '{path}' not found"
    except PermissionError:
        return f"Error: Permission denied accessing '{path}'"
    except Exception as e:
        return f"Error reading file '{path}': {str(e)}"


async def edit_file(path: str, old_str: str, new_str: str) -> str:
    """Make edits to a text file. Replaces 'old_str' with 'new_str' in the given file. 'old_str' and 'new_str' MUST be different from each other. If the file specified with path doesn't exist, it will be created."""
    file_path = Path(path)

    if old_str == new_str:
        return "Error: old_str and new_str must be different"

    try:
        if file_path.exists():
            content = file_path.read_text(encoding="utf-8")

            if old_str != "" and old_str not in content:
                return f"Error: old_str not found in file '{path}'"

            new_content = content.replace(old_str, new_str)
        else:
            if old_str != "":
                return f"Error: File '{path}' not found"

            file_path.parent.mkdir(parents=True, exist_ok=True)
            content = ""
            new_content = new_str

        if os.getenv("REQUIRE_EDIT_APPROVAL", "true").lower() == "true":
            diff_lines = generate_diff(content, new_content, path)

            if diff_lines:
                display_diff(diff_lines, path)

                approval = input("Apply changes? (y/n): ").strip().lower()
                if approval != "y":
                    return "User cancelled edit. Ask user for new instructions."
            else:
                logger.info("No changes detected")
                return "No changes to apply"

        file_path.write_text(new_content, encoding="utf-8")
        return f"Updated({path})"
    except Exception as e:
        return f"Error editing file '{path}': {str(e)}"


BASH_CMDS_APPROVAL_REQUIRED = ["rm", "rmdir", "rm -rf", "git reset"]


async def execute_bash(command: str) -> str:
    """Execute a bash command and return a formatted string with the results."""
    if any([command.strip().startswith(x) for x in BASH_CMDS_APPROVAL_REQUIRED]):
        approval = input(f"Cmd {command.strip()} requires approval. y to proceed): ")
        if approval.strip().lower() != "y":
            return "Command execution cancelled by user."

    try:
        result = subprocess.run(
            ["bash", "-c", command], capture_output=True, text=True, timeout=10
        )
        result_str = f"STDOUT:\n{result.stdout}\nSTDERR:\n{result.stderr}\nEXIT CODE: {result.returncode}"
        logger.info(f"[cyan bold]Bash({command}):[/cyan bold] {result_str}")
        return result_str
    except Exception as e:
        return f"Error executing command: {str(e)}"
